// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  // output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Temp {
  id          String   @id @default(cuid())
  created_at  DateTime @default(now())
  email       String   @unique
  otp         String   @unique
  expires_at  DateTime
  is_verified Int?     @default(0) // 0 for not verified, 1 for verified

  @@map("temp")
}

enum Status {
  active
  inactive
  suspended
  expired
  deactivated
}

enum Role {
  normal
  premium
  creator
  admin
}

enum CreatorPlan {
  basic
  family
  most_popular
}

enum CreatorChannelStatus {
  pending
  approved
  rejected
}

enum ReviewStatus {
  pending
  approved
  rejected
}

enum ChannelCategory {
  Entertainment
  Comedy
  Music
  Gaming
  Sports
  News
  Education
  Vlogs
}

model User {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?
  email      String    @unique
  name       String?
  address    String?
  password   String?

  customer_id     String?
  country         String?
  gender          String?
  status          Status    @default(active)
  role            Role      @default(normal)
  avatar          String? // public URL to avatar image
  date_of_birth   DateTime? @db.Date
  city            String?
  phone_number    String?
  suspend_endTime DateTime?
  state           String?
  postal_code     String?

  deactivation_start_date DateTime?
  deactivation_end_date   DateTime?

  is_subscribed          Boolean?       @default(false) // for newsletter subscription
  bio                    String?
  is_two_factor_enabled  Int?           @default(0)
  two_factor_secret      String? // secret key for two factor authentication
  //notification
  receiver_notifications Notification[] @relation("receiver")
  sender_notifications   Notification[] @relation("sender")
  Subscription           Subscription[]

  CreatorSubscription     CreatorSubscription[]
  creatorChannel          CreatorChannel?
  reviewedCreatorChannels CreatorChannel[]      @relation("creatorChannelReviewedBy")
  createdContents         Content[]             @relation("contentCreatedBy")
  reviewedContents        Content[]             @relation("contentReviewedBy")

  UserPaymentMethod  UserPaymentMethod[]
  orders             Order[]
  PaymentTransaction PaymentTransaction[]

  UserSetting UserSetting[]

  EmailHistoryRecipient EmailHistoryRecipient[]
  Rating                Rating[]
  Favourite             Favourite[]
  HelpSupport           HelpSupport[]
  contentViews          ContentView[]
  downloads             Download[]
  storageQuota          UserStorageQuota?

  @@map("users")
}

model CreatorService {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  name        String
  description String?
  features    String[]
  price       Float
  currency    String?

  plan             CreatorPlan
  videos_per_month Int?

  stripe_product_id String? @unique
  stripe_price_id   String? @unique

  subscriptions CreatorSubscription[]

  @@map("creator_services")
}

model CreatorSubscription {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  user_id String
  user    User   @relation(fields: [user_id], references: [id], onDelete: Cascade)

  creator_service_id String?
  service            CreatorService? @relation(fields: [creator_service_id], references: [id])

  renewal_date   DateTime?
  plan           CreatorPlan
  payment_method Payment_method @default(No_pay)
  transaction_id String         @unique // Stripe subscription id
  status         Status         @default(active)
  start_date     DateTime       @default(now())
  end_date       DateTime?

  PaymentTransaction PaymentTransaction[]

  @@index([user_id, status])
  @@map("creator_subscriptions")
}

model CreatorChannel {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  user_id String @unique
  user    User   @relation(fields: [user_id], references: [id], onDelete: Cascade)

  name   String
  slug   String  @unique
  bio    String?
  avatar String?
  banner String?

  channel_category ChannelCategory?

  sample_video_link String?

  status              CreatorChannelStatus @default(pending)
  reviewed_by_user_id String?
  reviewed_by         User?                @relation("creatorChannelReviewedBy", fields: [reviewed_by_user_id], references: [id])
  reviewed_at         DateTime?
  review_note         String?

  contents Content[]

  @@index([status])
  @@map("creator_channels")
}

model UserPaymentMethod {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  user_id String?
  user    User?   @relation(fields: [user_id], references: [id])

  payment_method_id String?
  checkout_id       String?

  @@map("user_payment_methods")
}

model Setting {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  category    String?
  label       String?
  description String?

  key           String? @unique
  default_value String?

  user_settings UserSetting[]

  @@map("settings")
}

model UserSetting {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  user_id String?
  user    User?   @relation(fields: [user_id], references: [id])

  setting_id String?
  setting    Setting? @relation(fields: [setting_id], references: [id])

  value String?

  @@map("user_settings")
}

model PaymentTransaction {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @updatedAt
  deleted_at DateTime?
  status     String    @default("pending") // "pending" | "requires_action" | "succeeded" | "failed" | "canceled"

  // --- Relations ---
  user_id String?
  user    User?   @relation(fields: [user_id], references: [id])

  subscription_id String?
  subscription    Subscription? @relation(fields: [subscription_id], references: [id])

  creator_subscription_id String?
  creator_subscription    CreatorSubscription? @relation(fields: [creator_subscription_id], references: [id])

  // --- Stripe / Provider identifiers (ðŸ”’ make processing idempotent & auditable) ---
  provider                   String?
  provider_payment_intent_id String? @unique
  provider_charge_id         String?
  provider_customer_id       String?
  provider_payment_method_id String?

  // --- Financials ---
  price          Decimal? // your major-unit price at time of purchase (e.g., 9.99)
  currency       String? // e.g., "usd"
  paid_amount    Decimal? // actual captured amount in major units (e.g., 9.99)
  paid_currency  String? // e.g., "usd"
  payment_method String? // duplicate of pm id for convenience/audit

  @@map("payment_transactions")
}

model NotificationEvent {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  status Int?    @default(1) @db.SmallInt
  type   String?
  text   String?

  notifications Notification[]

  @@map("notification_events")
}

model Notification {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  status Int? @default(1) @db.SmallInt

  sender_id String?
  sender    User?   @relation("sender", fields: [sender_id], references: [id])

  receiver_id String?
  receiver    User?   @relation("receiver", fields: [receiver_id], references: [id])

  notification_event_id String?
  notification_event    NotificationEvent? @relation(fields: [notification_event_id], references: [id])

  entity_id String?
  read_at   DateTime?

  @@map("notifications")
}

enum Plan {
  most_popular
  basic
  family
  No_plan
}

enum Payment_method {
  No_pay
  credit_card
  stripe
  paypal
}

model Subscription {
  id         String   @id @default(cuid())
  created_at DateTime @default(now())
  updated_at DateTime @default(now())

  username String?
  email    String?
  price    Float?

  user_id String?
  user    User?   @relation(fields: [user_id], references: [id])

  renewal_date   DateTime?
  plan           Plan           @default(No_plan)
  payment_method Payment_method @default(No_pay)
  transaction_id String
  status         Status         @default(active)

  start_date DateTime  @default(now())
  end_date   DateTime?

  PaymentTransaction PaymentTransaction[]

  Order Order[]

  Services Services[]
}

model Services {
  id          String   @id @default(cuid())
  created_at  DateTime @default(now())
  name        String
  description String?
  price       Float
  features    String[]
  plan        Plan

  stripe_product_id String? @unique
  stripe_price_id   String? @unique

  Subscription Subscription[]

  @@map("services")
}

model Live_streaming {
  id         String   @id @default(cuid())
  created_at DateTime @default(now())

  all_live    String[]
  live_sports String[]
}

model Favourite {
  id         String   @id @default(cuid())
  created_at DateTime @default(now())

  content_id String?
  content    Content? @relation(fields: [content_id], references: [id], onDelete: Cascade)

  user_id String?
  user    User?   @relation(fields: [user_id], references: [id])

  category_id String?
  category    Category? @relation(fields: [category_id], references: [id], onDelete: Cascade)

  title       String?
  thumbnail   String? // optional public URL
  description String?
  rating      Int?    @default(0) // rating out of 5

  @@unique([user_id, content_id])
  @@map("favourites")
}

model Admin_settings {
  id         String   @id @default(cuid())
  created_at DateTime @default(now())
}

// for movie

enum Genra {
  action
  adventure
  animation
  biography
  comedy
  crime
  documentary
  drama
  family
  fantasy
  history
  horror
  music
  musical
  mystery
  romance
  sci_fi
  sport
  thriller
  war
  western
}

enum Content_status {
  published
  draft
  uploading_local
  uploading_s3
  processing
  failed
}

enum statusType {
  published
  pending
  unpublished
  archived
  deleted
}

enum ContentType {
  movie
  series
  episode
  trailer
  music_video
}

model Content {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @updatedAt
  deleted_at DateTime?

  title       String?
  description String?

  genre       Genra[]
  category_id String?
  category    Category? @relation(fields: [category_id], references: [id])

  content_type ContentType @default(movie) // movie | series | episode
  mime_type    String? // "video/mp4", "video/webm", "video/quicktime"

  duration_seconds Int?

  content_status Content_status
  // status         statusType?

  storage_provider String?
  s3_bucket        String?
  s3_key           String?
  s3_thumb_key     String?
  original_name    String?
  file_size_bytes  BigInt?
  etag             String?
  checksum_sha256  String?

  quality    String?
  view_count Int     @default(0)

  thumbnail String?
  video     String?

  is_premium Boolean @default(false)

  series_id      String?
  season_number  Int?
  episode_number Int?

  release_date DateTime?

  // Trailer relationship - if content_type is 'trailer', this points to what content this trailer is for
  trailer_for_id String?
  trailer_for    Content?  @relation("TrailerOf", fields: [trailer_for_id], references: [id])
  trailers       Content[] @relation("TrailerOf")

  parent_series Content?  @relation("SeriesEpisodes", fields: [series_id], references: [id])
  episodes      Content[] @relation("SeriesEpisodes")

  Rating      Rating[]
  Favourite   Favourite[]
  ContentView ContentView[]
  Cast        Cast[]
  downloads   Download[]    @relation("UserDownloads")

  created_by_user_id String?
  created_by         User?   @relation("contentCreatedBy", fields: [created_by_user_id], references: [id])

  review_status       ReviewStatus @default(approved)
  reviewed_by_user_id String?
  reviewed_by         User?        @relation("contentReviewedBy", fields: [reviewed_by_user_id], references: [id])
  reviewed_at         DateTime?
  review_note         String?

  creator_channel_id String?
  creator_channel    CreatorChannel? @relation(fields: [creator_channel_id], references: [id])

  @@unique([series_id, season_number, episode_number])
  @@index([category_id])
  @@index([is_premium])
  // @@index([status])
  @@index([release_date])
  @@index([series_id])
  @@index([view_count])
  @@index([deleted_at])
}

model ContentView {
  id        String   @id @default(cuid())
  viewed_at DateTime @default(now())

  user_id    String
  content_id String

  user    User?   @relation(fields: [user_id], references: [id])
  content Content @relation(fields: [content_id], references: [id], onDelete: Cascade)

  @@index([user_id, content_id, viewed_at])
  @@index([content_id, viewed_at])
  @@index([user_id])
  @@map("content_views")
}

model Cast {
  id         String    @id @default(cuid())
  created_at DateTime? @default(now())
  updated_at DateTime? @default(now())
  deleted_at DateTime?
  status     Int?      @default(1) @db.SmallInt

  name       String?
  role       String? // e.g., Actor, Director, Producer
  bio        String?   @db.Text
  birth_date DateTime? @db.Date
  photo      String? // public URL to photo image

  content   Content? @relation(fields: [contentId], references: [id], onDelete: Cascade)
  contentId String?

  @@map("casts")
}

model Rating {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  user_id String?
  user    User?   @relation(fields: [user_id], references: [id])

  content_id String?
  content    Content? @relation(fields: [content_id], references: [id], onDelete: Cascade)

  rating  Int?    @default(0)
  comment String?

  @@unique([user_id, content_id])
  @@map("ratings")
}

model Category {
  id         String    @id @default(cuid())
  created_at DateTime? @default(now())
  updated_at DateTime? @default(now())
  deleted_at DateTime?
  status     Int?      @default(1) @db.SmallInt

  name String?
  slug String? @unique

  contents  Content[]
  Favourite Favourite[]

  @@map("categories")
}

model Feature {
  id         String    @id @default(cuid())
  created_at DateTime? @default(now())
  updated_at DateTime? @default(now())
  deleted_at DateTime?
  status     Int?      @default(1) @db.SmallInt

  name String?

  @@map("features")
}

model SecuritySettings {
  id         String    @id @default(cuid())
  created_at DateTime? @default(now())
  updated_at DateTime? @default(now())
  deleted_at DateTime?
  status     Int?      @default(1) @db.SmallInt

  data_export_backup    Int?
  session_timeout       Int?
  failed_login_attempts Int?
  password_expiry       Int?

  @@map("security_settings")
}

// this table stores Email history
model EmailHistory {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?
  status     Int?      @default(1) @db.SmallInt
  sort_order Int?      @default(0)

  type    String? // Password Reset, Email Verification, etc.
  subject String?
  body    String? @db.Text

  email_history_recipients EmailHistoryRecipient[]

  @@map("email_histories")
}

// this table stores Email history recipient
model EmailHistoryRecipient {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  email_history_id String
  email_history    EmailHistory? @relation(fields: [email_history_id], references: [id], onDelete: Cascade)

  recipient_id String
  recipient    User?  @relation(fields: [recipient_id], references: [id], onDelete: Cascade)

  @@map("email_history_recipients")
}

enum clintStatus {
  active
  inactive
}

enum paymentStatus {
  paid
  pending
  due
}

enum OrderStatus {
  progress
  completed
  pending
  canceled
}

model Order {
  id         String   @id
  created_at DateTime @default(now())

  order_status OrderStatus @default(progress)

  subscription_id String?
  subscription    Subscription? @relation(fields: [subscription_id], references: [id])

  user_id String?
  user    User?   @relation(fields: [user_id], references: [id])

  status         clintStatus   @default(active)
  ammount        Float?
  user_name      String?
  user_email     String?
  pakage_name    String?
  payment_status paymentStatus @default(pending)

  @@map("orders")
}

enum HelpSupportStatus {
  Open
  Resolved
}

model HelpSupport {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  username String?
  email    String?
  user_id  String?
  user     User?   @relation(fields: [user_id], references: [id])

  subject     String?
  description String? @db.Text

  status HelpSupportStatus @default(Open)

  @@map("help_and_support")
}

// Download storage for offline viewing
enum DownloadStatus {
  pending
  downloading
  completed
  paused
  failed
  cancelled
}

enum StorageTier {
  basic // 5 GB
  most_popular // 50 GB
  family // 100 GB
  No_plan // 0 GB (typically means no quota record)
}

model Download {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @updatedAt
  deleted_at DateTime?

  user_id String
  user    User   @relation(fields: [user_id], references: [id], onDelete: Cascade)

  content_id String
  content    Content @relation("UserDownloads", fields: [content_id], references: [id], onDelete: Cascade)

  status           DownloadStatus @default(pending)
  quality          String? // "480p", "720p", "1080p", "4k"
  progress         Int            @default(0) // 0-100 percentage
  file_size_bytes  BigInt?
  downloaded_bytes BigInt         @default(0)
  expires_at       DateTime? // When download will auto-delete (optional)

  // File storage paths
  file_path String? // Local: /downloads/users/{userId}/{contentId}.mp4
  s3_key    String? // S3: users/{userId}/{contentId}.mp4 (for future migration)

  // Error tracking
  error_message String?
  failed_count  Int     @default(0)

  @@unique([user_id, content_id])
  @@index([user_id, status])
  @@index([expires_at])
  @@map("downloads")
}

model UserStorageQuota {
  id         String   @id @default(cuid())
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  user_id String @unique
  user    User   @relation(fields: [user_id], references: [id], onDelete: Cascade)

  tier                   StorageTier @default(No_plan)
  total_storage_bytes    BigInt // Total allowed storage
  used_storage_bytes     BigInt      @default(0) // Currently used storage
  auto_delete_enabled    Boolean     @default(true) // Auto-delete old downloads
  auto_delete_days       Int         @default(30) // Delete downloads older than X days
  notification_threshold Int         @default(80) // Notify when % of storage used

  @@map("user_storage_quotas")
}
